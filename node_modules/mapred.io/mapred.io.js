/**
 * MapReduce implementation based on socket.io
 */
var sio = require('socket.io');
var Manager = require('socket.io').Manager;
var EventEmitter = process.EventEmitter;
/**
 * Export the constructor.
 */


function Mapred (server, options) {
	Manager.call(this, server, options);
	this.jobs = {};
	this.tasks = [];
	this._global = this.store.client(this.generateId());
	this.init();
};

Mapred.prototype.__proto__ = Manager.prototype;

Mapred.prototype.init = function()
{
	this.static.add('/mapred.io.js', {file: __dirname + '/mapred.io-client.js'});

	var self = this;
	this.on('connection', function(socket){
		this.log.info(socket.id + ' joined this cluster.');
		
		socket.emit('ready', socket.id);
		var clients = this.sockets.clients(), i;
		for(i=0;i<clients.length;i++)if(clients[i].id !== socket.id) socket.emit('join', clients[i].id)
		this.sockets.emit('join', socket.id);
		socket.on('job', function(jobconf){
			// listing the client to submit one job.
			// create new job, split the inputs and start to run map tasks.
			this.log.info(socket.id + ' have submit one job.');
			var job = new JobConf(self, jobconf, socket.id);
			self.jobs[job.id] = job;
			socket.emit('submit', job.id);
			job.initMapTask();
		});
		socket.on('task', function(jobconf){
			if (self.tasks.length)
			{
				var t = self.tasks.shift();
				self._global.get(t[2] + '_' + t[0], function(err, datas){
					var data = {id: t[0], jobId: t[1], datas:  datas};
					data[t[2]] = self.jobs[t[1]].conf[t[2]];
					socket.set('task', t);
					socket.emit(t[2], data);
					self.log.info('assign '+ t[2] +' task: '+t[0]+' to ' + socket.id);
				})
			}
		})
		socket.on('flod', function(data){
			// set status of the map tasks, and assign next task to this client if another one not running,
			// if all map tasks are complated then merge all the results and start to run reduce tasks.
			var job = self.jobs[data.jobId];
			this.log.info('complated map task: ' + data.id + ' of job: ' + data.jobId + ' on client: ' + socket.id);
			job.emit('map-complated', data)
		});
		socket.on('result', function(data){
			var job = self.jobs[data.jobId];
			this.log.info('complated reduce task: ' + data.id + ' of job: ' + data.jobId + ' on client: ' + socket.id);
			job.emit('reduce-complated', data)
		});
		socket.on('status', function(data){
			socket.emit('status', {tasks: self.tasks})
			//socket.emit('status', {sockets: self.sockets.clients()})
		});
		socket.on('disconnect', function(data){
			socket.get('task', function(err, task){
				if (err || (!task)) return;
				self.tasks.push(task)
			})
			self.sockets.emit('leave', socket.id);
		});
		socket.on('error', function(data){
			self.sockets.emit('leave', socket.id);
			socket.get('task', function(err, task){
				if (err || (!task)) return;
				self.tasks.push(task)
			})
		});
	})

}
Mapred.prototype.submitTask = function(id, jobId, event, data)
{
	this.tasks.push([id, jobId, event]);
	this._global.set(event + '_' + id, data);
}

function JobConf(manager, conf, clientId)
{
	this.time = {start: new Date()};
	this.manager = manager;
	this.conf = conf;
	this.clientId = clientId;
	this.inputSize = 0;
	this.id = manager.generateId();
	this.mapTaskNum = conf.mapTaskNum || 0;
	this.mapTasks = [];
	this.reduceTaskNum = conf.reduceTaskNum || 0;
	this.reduceTasks = [];
}

JobConf.prototype.__proto__ = EventEmitter.prototype;

JobConf.prototype.initMapTask = function()
{
	if(!this.mapTaskNum) this.mapTaskNum = this.manager.sockets.clients().length * 2;
	var i = 0, pieces = this.conf.inputs, num = this.mapTaskNum, len = Math.floor(pieces.length / this.mapTaskNum) + 1;
	this.inputSize = pieces.length;
	while(pieces.length)
	{
		this.manager.submitTask(this.mapTasks[i++] = this.manager.generateId(), this.id, 'map', pieces.splice(0, len));
	}
	this.time['initMapTask'] = new Date();
	
	this.on('map-complated', function(mapTask){
		this.manager._global.set('flod_' + mapTask.id, mapTask.groups);
		if(--this.mapTaskNum === 0) this.initReduceTask();
	});
	this.manager.log.info('success to init the map tasks(' + this.mapTaskNum + ')');
}

JobConf.prototype._merge = function(map, callback)
{
	var groups = {}, tasks = (map ? this.mapTasks : this.reduceTasks), prefix = (map ? 'flod_' : 'result_'), count = 0;
	for (var id in tasks)
	{
		this.manager._global.get(prefix + tasks[id], function(err, datas){
			for (var key in datas)
				if (groups[key]) 
					groups[key] = groups[key].concat(datas[key]);
				else {
					groups[key] = datas[key]; 
					count++;
				}
		})
		
	}
	callback && callback(this, groups, count);
}

JobConf.prototype.initReduceTask = function()
{
	// merge all results from maper...............
	this._merge(true, function(job, groups, count){
		if(!job.reduceTaskNum) job.reduceTaskNum = job.manager.sockets.clients().length;
		job.reduceTaskNum = job.reduceTaskNum > count ? count : job.reduceTaskNum;
		var num = job.reduceTaskNum, i = 0;
		var flods = [];
		for (var key in groups)
		{
			var index = ++i % num;
			if(!(flods[index])) flods[index] = {};
			flods[index][key] = groups[key];
		}
		for (i=0; i < num; i++)
		{
			job.manager.submitTask(job.reduceTasks[i] = job.manager.generateId(), job.id, 'reduce', flods[i]);
		}
		job.time['initReduceTask'] = new Date();
		job.on('reduce-complated', function(reduceTask){
			this.manager._global.set('result_' + reduceTask.id, reduceTask.groups);
			if(--this.reduceTaskNum === 0) this.complated();
		});
		job.manager.log.info('success to init the reduce tasks(' + job.reduceTaskNum + ')');
	})
	
}


JobConf.prototype.complated = function(){
	this._merge(false, function(job, groups){
		job.time['end'] = new Date();
		job.time['using'] = job.time['end'] - job.time['start'];
		job.manager.log.info('complated job (' + job.id + ') in (' + job.time.using + 'ms), send result to client: ' + job.clientId);
		job.manager.sockets.socket(job.clientId).emit('result', {jobconf:{time: job.time, jobid: job.id, mapTaskNum: job.mapTasks.length, reduceTaskNum: job.reduceTasks.length, inputSize: job.inputSize}, results:groups})
	});
}

sio.Manager = Mapred;
sio.Client = require('./mapred.io-client.js').MapredClient;
exports = module.exports = sio;
